#include"LevelLines.hpp"
#include"TextWriter.hpp"
#include<string>
#include"Log.hpp"
LevelLines::LevelLines(TileContainer* _tilecont, const nes_ushort& _frameappearance, const nes_uchar& _level)
    :Renderer(_tilecont, _frameappearance), starting_level(_level), real_level(_level), shown_level(_level), lines(0u)
{
    linestolevelup=(real_level+1)/16*100;
    if ((real_level+1)%16>=10) linestolevelup+=100;
    else linestolevelup+=((real_level+1)%16)*10;
}

void LevelLines::render(Audio& _audio) {
    if (ntris::updatingmatrix <= 0 && ntris::lineclearframecounter <= 0) {
        if (shown_level != real_level) {
            _audio.playLevelUp();
            shown_level = real_level;
        }
    }
    if (hidecounter>0) {
        --hidecounter;
        return;
    }
    else {
        if (ntris::lineclearframecounter) { //IT UPDATES AFTER LINECLEARFRAMECOUNTER AND BEFORE UPDATINGAMATRIX
            TextWriter::write_hex(linestemp[0], tilecont, {ntris::linesx+1,ntris::linesy},2);
            TextWriter::write_hex(linestemp[1], tilecont, {ntris::linesx,ntris::linesy},1);

            TextWriter::write_hex(level_hex[shown_level],tilecont,{ntris::levelx+2,ntris::levely+1},2);
        }
        else {
            TextWriter::write_hex(lines[0], tilecont, {ntris::linesx+1,ntris::linesy},2);
            TextWriter::write_hex(lines[1], tilecont, {ntris::linesx,ntris::linesy},1);

            TextWriter::write_hex(level_hex[real_level],tilecont,{ntris::levelx+2,ntris::levely+1},2);
        }
    }
}

const nes_uchar& LevelLines::get_real_level() const {
    return real_level;
}

const nes_uchar& LevelLines::get_shown_level() const {
    return shown_level;
}

const nes_uchar& LevelLines::get_starting_level() const {
    return starting_level;
}

unsigned int LevelLines::getLines() const
{
    return lines.reallines();
}

nes_uchar LevelLines::getTetrisPercentage() const
{
    if (total_lines_cleared == 0) return 0;
    nes_uchar tetris_percentage = (nes_uchar)(((long double)tetris_lines_cleared*100) / ((long double)total_lines_cleared));
    return tetris_percentage;
}

void LevelLines::addlines(const nes_uchar& _clearedlines) {
    linestemp=lines;
    shown_level=real_level;
    lines.addLines(_clearedlines);
    if (lines.reallines()>=linestolevelup) {
        ++real_level;
        linestolevelup+=10;
    }
    if (_clearedlines >= 4) {
        tetris_lines_cleared += _clearedlines;
    }
    total_lines_cleared += _clearedlines;
}

nes_uchar LevelLines::level_hex[256]={
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x10,0x11,0x12,0x13,0x14,0x15,
    0x16,0x17,0x18,0x19,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x00,0x0A,
    0x14,0x1E,0x28,0x32,0x3C,0x46,0x50,0x5A,0x64,0x6E,0x78,0x82,0x8C,0x96,0xA0,0xAA,
    0xB4,0xBE,0xC6,0x20,0xE6,0x20,0x06,0x21,0x26,0x21,0x46,0x21,0x66,0x21,0x86,0x21,
    0xA6,0x21,0xC6,0x21,0xE6,0x21,0x06,0x22,0x26,0x22,0x46,0x22,0x66,0x22,0x86,0x22,
    0xA6,0x22,0xC6,0x22,0xE6,0x22,0x06,0x23,0x26,0x23,0x85,0xA8,0x29,0xF0,0x4A,0x4A,
    0x4A,0x4A,0x8D,0x07,0x20,0xA5,0xA8,0x29,0x0F,0x8D,0x07,0x20,0x60,0xA6,0x49,0xE0,
    0x15,0x10,0x53,0xBD,0xD6,0x96,0xA8,0x8A,0x0A,0xAA,0xE8,0xBD,0xEA,0x96,0x8D,0x06,
    0x20,0xCA,0xA5,0xBE,0xC9,0x01,0xF0,0x1E,0xA5,0xB9,0xC9,0x05,0xF0,0x0C,0xBD,0xEA,
    0x96,0x38,0xE9,0x02,0x8D,0x06,0x20,0x4C,0x67,0x97,0xBD,0xEA,0x96,0x18,0x69,0x0C,
    0x8D,0x06,0x20,0x4C,0x67,0x97,0xBD,0xEA,0x96,0x18,0x69,0x06,0x8D,0x06,0x20,0xA2,
    0x0A,0xB1,0xB8,0x8D,0x07,0x20,0xC8,0xCA,0xD0,0xF7,0xE6,0x49,0xA5,0x49,0xC9,0x14,
    0x30,0x04,0xA9,0x20,0x85,0x49,0x60,0xA5,0xB1,0x29,0x03,0xD0,0x78,0xA9,0x00,0x85,
    0xAA,0xA6,0xAA,0xB5,0x4A,0xF0,0x5C,0x0A,0xA8,0xB9,0xEA,0x96,0x85,0xA8,0xA5,0xBE,
    0xC9,0x01,0xD0,0x0A,0xA5,0xA8,0x18,0x69,0x06,0x85,0xA8,0x4C,0xBD,0x97,0xA5,0xB9,
    0xC9,0x04,0xD0,0x0A,0xA5,0xA8,0x38,0xE9,0x02,0x85,0xA8,0x4C,0xBD,0x97,0xA5,0xA8
};
